<meta charset="utf-8">
<h1>xroads-game</h1>

<p>I have always been addicted to these:</p>

<p><img src="pics/lego-plate-1.png" alt="Lego-plate" /></p>

<p>So let&rsquo;s paint some roads using the Haskell programming language.</p>

<h2>Red Dots</h2>

<p>A point is represented by the data type <code>Point</code>. We create a list of some example points.</p>

<pre><code class="haskell">data Point = Point Double Double
points = [Point 200 100, Point 100 300, Point 300 200]
</code></pre>

<p>We fill the canvas by white and draw each point by the functions <code>drawMarkerAt</code> and <code>drawOneMarker</code>.</p>

<pre><code class="haskell">drawOneMarker bw (r,g,b) = do
  rectangle (-0.5*bw) (-0.5*bw) bw bw
  setSourceRGBA r g b 0.8
  fill

drawMarkerAt (Point x y) = do
  save
  translate x y
  drawOneMarker 20.0 red
  restore

paintCanvas = do
  setSourceRGB 1 1 1
  paint
  mapM_ drawMarkerAt points
</code></pre>

<p>The result is an image surface of size 400x400px, which we write to a file.</p>

<pre><code class="haskell">createPng fileName = do
  let w = 400
      h = 400
  img &lt;- createImageSurface FormatARGB32 w h
  renderWith img paintCanvas
  surfaceWriteToPNG img fileName
</code></pre>

<p>The full code for the red dots is here: <a href="code/red-dots.hs">red-dots.hs</a></p>

<p><img src="pics/red-dots.png" alt="red-dots" /></p>

<h2>Orange Lines</h2>

<p>To connect the points, we define the data type for vector. The colors are represented as RGB or RGBA color.</p>

<pre><code class="haskell">data Vector = Vector Double Double
data RGBA = RGB  Double Double Double
          | RGBA Double Double Double Double
</code></pre>

<p>The colors now become</p>

<pre><code class="haskell">white  = RGBA 1.00 1.00 1.00 1.00
red    = RGB  0.88 0.29 0.22
orange = RGB  0.98 0.63 0.15
yellow = RGB  0.97 0.85 0.39
green  = RGB  0.38 0.74 0.43
darkGreen = RGB 0.00 0.66 0.52
</code></pre>

<p>We get the line segments and corresponding vectors by</p>

<pre><code class="haskell">mkVector (Point x0 y0) (Point x1 y1) =
  Vector (x1 - x0) (y1 - y0)

points = [Point 200 100, Point 100 300, Point 300 200]
segments = zip points (tail (cycle points))
vectors = map (uncurry mkVector) segments
</code></pre>

<p>The function <code>uncurry</code> from Prelude is used to unzip the tuple made by <code>zip</code>. To draw one vector, we use</p>

<pre><code class="haskell">drawVector (Point x y) (Vector dx dy) = do
  setColor orange
  moveTo x y
  relLineTo dx dy
  stroke
</code></pre>

<p>Again, we clear the canvas and paint the markers and vectors connecting them.</p>

<pre><code class="haskell">paintCanvas = do
  setSourceRGB 1 1 1
  paint
  mapM_ drawMarkerAt points
  mapM_ (uncurry drawVector) (zip points vectors)
</code></pre>

<p>The full code for the orange lines: <a href="code/orange-lines.hs">orange-lines.hs</a></p>

<p><img src="pics/orange-lines.png" alt="orange-lines" /></p>

<h2>Yellow Normals</h2>

<p>Next we find out the normals for each start point and end point. When the points are ordered counterclockwise, we get the outside pointing normal for a vector by</p>

<pre><code class="haskell">normal (Vector dx dy) = 
  Vector (-dy) dx
</code></pre>

<p>We need the magnitude of the vector, so we can draw a multitude of its unit vector.</p>

<pre><code class="haskell">dist (Point x0 y0) (Point x1 y1) = 
  sqrt ((sqr dx) + (sqr dy))
  where
    sqr x = x * x
    dx = x1 - x0
    dy = y1 - y0

magnitude (Vector dx dy) =
  dist (Point 0 0) (Point dx dy)

unit r (Vector dx dy) = 
  Vector (r * dx / mag) (r * dy / mag)
  where
    mag = magnitude (Vector dx dy)
</code></pre>

<p>Besides points and segments, we now get the start points, end points, vectors between them and the unit normals:</p>

<pre><code class="haskell">points = [Point 200 100, Point 100 300, Point 300 200]
segments = zip points (tail (cycle points))
startPoints = map fst segments
endPoints = map snd segments
vectors = map (uncurry mkVector) segments
normals = map normal vectors
units = map (unit 1.0) normals
</code></pre>

<p>We stroke the normals in a loop</p>

<pre><code class="haskell">paintCanvas = do
  setSourceRGB 1 1 1
  paint
  mapM_ drawMarkerAt points
  mapM_ (uncurry (drawVector orange)) (zip points vectors)
  mapM_ (uncurry (drawVector yellow)) (zip startPoints units)
  mapM_ (uncurry (drawVector yellow)) (zip endPoints units)
</code></pre>

<p>The full code for the normals: <a href="code/yellow-normals.hs">yellow-normals.hs</a></p>

<p><img src="pics/yellow-normals.png" alt="yellow-normals" /></p>

<h2>Green Roads</h2>

<p>The roadline is drawn using functions <code>drawLine</code> and <code>drawArc</code>. Function <code>drawLine</code> is used on straight paths and function <code>drawArc</code> on curves.</p>

<pre><code class="haskell">paintRoadLine r = do
  mapM_ (uncurry (drawLine green)) (zip rStart rEnd)
  mapM_ (uncurry3 (drawArc green r)) arcs2
  where
    rVec = map (unit r) normals
    rStart = map (uncurry toPoint) (zip startPoints rVec)
    rEnd = map (uncurry toPoint) (zip endPoints rVec)
</code></pre>

<p>We take some measurements from the Lego-plates</p>

<pre><code class="haskell">plateW = 100
roadMarks = [0.286, 0.307, 0.491]
r1 = plateW * roadMarks !! 0
r2 = plateW - r1
</code></pre>

<p>For an arc we need its center point, radius, start angle and end angle</p>

<pre><code class="haskell">drawArc color r (Point x y) angle1 angle2 = do
  setColor color
  arc x y r angle1 angle2
  stroke
</code></pre>

<p>To get the calculations correct, we use <code>testPolygon</code> and <code>testDodecagon</code> as shape. For clarity the number <code>tau = 6.28318530717958647692</code> is used instead of <code>pi</code>.</p>

<pre><code class="haskell">testPolygon = [Point 200 100, Point 100 200, Point 100 300, Point 300 200]
testDodecagon = 
  [Point (200 + radius * cos a)(200 - radius * sin a)| a &lt;- angles]
  where
   radius = 100
   corners = 12
   angles = [i * (tau/corners) | i &lt;- [0..corners-1]]
</code></pre>

<p><img src="pics/green-roads-dodecagon.png" alt="green-dodecagon-polygon" /></p>

<p>Given the vector, vectorangle can be calculated as follows:</p>

<pre><code class="haskell">vectorAngle (Vector x y) 
  | y &gt;= 0   = acos x
  | otherwise = -(acos x)
</code></pre>

<p>This is used to get the start angle and end angle of the arc. The function <code>drawArc</code> takes the center point, start angle and end angle as parameters. We have zipped them to a triple by the function <code>zip3</code> so we need the function <code>uncurry3</code> to unzip the parameters.</p>

<pre><code class="haskell">uncurry3 f (a,b,c) = f a b c
</code></pre>

<p>The full code for the green roads: <a href="code/green-roads.hs">green-roads.hs</a></p>

<p><img src="pics/green-roads-polygon.png" alt="green-roads-polygon" /></p>

<h2>Dark Green Points</h2>

<p>Our initial purpose was to paint a road which goes through a set of given points. Let&rsquo;s get back to this purpose, and define the actual points:</p>

<pre><code class="haskell">darkPoly = [Point 200 50, Point 55 180, Point 75 340, Point 345 210]
</code></pre>

<p><img src="pics/dark-green-points.png" alt="dark-green-points" /></p>

<p>The simplified code looks now like: <a href="code/dark-green-points.hs">dark-green-points.hs</a></p>

<h2>Blue Vectors</h2>

<p>To get the curves go through the points, we need to find the center point for the arc, that formes the curve. It probably is somewhere along the half of the angles between the defining points. Let&rsquo;s first find the angles.</p>

<pre><code class="haskell">points = darkPoly
dirTriplets = transpose [rotList r points | r &lt;- [-1,0,1]]
dirVecs2 = map (\[a,b,c] -&gt; [(b,mkVector b a),(b,mkVector b c)]) dirTriplets
dirVecs = concat dirVecs2
dirUnits50 = map (\(s,v) -&gt; (s, unit 50 v)) dirVecs
</code></pre>

<p>The function <code>transpose</code> from the module <code>Data.List</code> works with lists as follows:</p>

<pre><code class="haskell">import Data.List
transpose ["ABCD","abcd","1234"]
 ⇒ ["Aa1","Bb2","Cc3","Dd4"]
</code></pre>

<p>We define the function <code>rotList</code> to rotate a list. We use this to get nicely the triplets of previous, current and next point.</p>

<pre><code class="haskell">rotList n xs = take size (drop (n `mod` size) (cycle xs))
  where size = length xs
</code></pre>

<p>Now</p>

<pre><code class="haskell">rotList (-1) "ABCDE" ⇒ "EABCD"
rotList 0 "ABCDE" ⇒ "ABCDE"
rotList 1 "ABCDE" ⇒ "BCDEA"

map (\n -&gt; rotList n "ABCDE") [-1,0,1]
 ⇒ ["EABCD","ABCDE","BCDEA"]
</code></pre>

<p><img src="pics/blue-vectors.png" alt="blue-vectors" /></p>

<p>The full code to find the directed vectors: <a href="code/blue-vectors.hs">blue-vectors.hs</a></p>

<h2>Dark Blue Halves</h2>

<p>The angle between two vectors can be calculatated by the function <code>acos</code>, but there is an another more useful function <code>atan2</code> for the same purpose. It gives angles inside full turn without conditioning.</p>

<pre><code class="haskell">axisX = Vector 1.0 0.0

vectorAngle (Vector x1 y1) (Vector x2 y2) =
  atan2 (x1*y2 - y1*x2) (x1*x2 + y1*y2)
</code></pre>

<p>Using this definition, we find the angle between vector and X-axis using the function <code>(vectorAngle axisX)</code></p>

<pre><code class="haskell">dirAngles = map (vectorAngle axisX) dirUnits
</code></pre>

<p><img src="pics/blue-atan2.png" alt="blue-atan2" /></p>

<p>Everything seems to be upside-down because the coordinate origo situates in upper-left corner. We&rsquo;ll just ignore this. The angle of the fourth point gives us a negative number, because the actual angle is on the opposite side, but we can find use for this observation later.</p>

<p>The source code for this: <a href="code/blue-atan2.hs">blue-atan2.hs</a></p>

<h2>Back to Road</h2>

<p>The half angles become thus the first of <code>dirAngles</code> added to the half of the <code>dirBetween</code></p>

<pre><code class="haskell">dirHalves = map 
  (\(a,b) -&gt; b + 0.5*a) 
  (zip dirBetween (pairwise (\a b -&gt; a) dirAngles))
</code></pre>

<p>We go half of the plate width to the direction of half angle, and convert the vector arrow to a point.</p>

<pre><code class="haskell">dirHVecs = map (vectorFromAngle (0.5*plateW)) dirHalves
points = map (uncurry toPoint) (zip darkPoly dirHVecs)
</code></pre>

<p>Now we have recalculated the original Red Points and can bring the road back.</p>

<p><img src="pics/back-to-road.png" alt="back-to-road" /></p>

<p>We observe how our road became smarter than us. This is of course wrong&hellip;</p>

<p>The code: <a href="code/back-to-road.hs">back-to-road</a></p>

<h2>Distinguish Convex and Concave</h2>

<p>Curves on road are either convex or concave. We represent this by data type <code>Curving</code>:</p>

<pre><code class="haskell">data Curving = Convex | Concave
</code></pre>

<p>We know from earlier, that curve is convex, when (following the path counterclockwise) it&rsquo;s angle remains on the upper half of unit circle. There the function <code>vectorAngle</code> returns a positive number:</p>

<pre><code class="haskell">curved angle 
 | angle &gt;= 0  = Convex
 | otherwise   = Concave
</code></pre>

<p>Having made the definitions</p>

<pre><code class="haskell">dirBetween = pairwise vectorAngle dirUnits
dirCurved  = map curved dirBetween
</code></pre>

<p>we get</p>

<pre><code class="haskell">dirBetween = 
[1.707862501105084,0.45093642923738,-2.158798930342464,
-2.158798930342464,0.45093642923738, 1.707862501105084]
dirCurved = [Convex,Convex,Concave,Concave,Convex,Convex]
</code></pre>

<p>The orientation of straight road segment can be concluded from the convexity of its start and end point. The orientation of arc can be concluded from the convexity of previous, current and next point. Because the list of convexity becomes quite long, we abbreviate convex turn as <code>x</code> and concave turn as <code>o</code>:</p>

<pre><code class="haskell">ox Convex  = 'x'
ox Concave = 'o'
</code></pre>

<p>With the given six points, we thus get</p>

<pre><code class="haskell">dirOx = map ox dirCurved
 ⇒ "xxooxx"
</code></pre>

<p>From this, ge get the cycled pairs and cycled triples:</p>

<pre><code class="haskell">dirCycledPairs = cycledPairs dirOx
dirCycledTriples = cycledTriples dirOx

cycledTriples xs = 
  zipWith3 (\a b c -&gt; a:b:[c]) (rotList (-1) xs) xs (rotList 1 xs)
cycledPairs xs = zipWith (\a b -&gt; a:[b]) xs (rotList 1 xs)
pairwise f (x:y:zs) = f x y : pairwise f zs
pairwise f _ = []
rotList n xs = take size (drop (n `mod` size) (cycle xs))
  where size = length xs
</code></pre>

<p>We get</p>

<pre><code class="haskell">dirOx = "xxooxx"
dirCycledPairs = ["xx","xo","oo","ox","xx","xx"]
dirCycledTriples = ["xxx","xxo","xoo","oox","oxx","xxx"]
</code></pre>

<p>We use the triplets as parameters when calculating the new normals. The incoming normal gets all the needed information of convexity from the first two letters of a triplet and the outgoing from the last two. For this we use the functions <code>init</code> and <code>tail</code>.</p>

<pre><code class="haskell">init "xox" ⇒ "xo"
tail "xox" ⇒ "ox"
</code></pre>

<h2>New normals</h2>

<p>We use the convexity, coordinates and some old normals to calculate the new normals, which are a bit more correct than the old ones.</p>

<pre><code class="haskell">calcVecs curves points units =
  map (uncurry3 calcVec) z
  where
  z = zip3 
    (cycledTriples (map ox curves))
    (cycledTriples points)
    (cycledTriples vecAngles)
</code></pre>

<p>Each point has two normals, the incoming <code>prevNew</code> and the outgoing <code>nextNew</code>. We create them as a pair <code>[prevNew,nextNew]</code>. In every case the start point of the vector is the original point <code>thisPt</code>. In convex case <code>"xx"</code> the normal goes to the direction of already calculated normal, having the angle <code>prevAg</code>. The same is true for concave case <code>"oo"</code>, but the normal goes to opposite direction.</p>

<pre><code class="haskell">calcVec crv pts ags =
  [prevNew,nextNew] 
  where
    prevNew = case prevOx of
      "xx" -&gt; Vec thisPt prevAg
      "oo" -&gt; Vec thisPt (opposite prevAg)
      "xo" -&gt; Vec thisPt (opposite (angleRS prevPt thisPt (+)))
      "ox" -&gt; Vec thisPt (opposite (angleRS prevPt thisPt (-)))
      _    -&gt; None
    nextNew = case nextOx of
      "xx" -&gt; Vec thisPt thisAg
      "oo" -&gt; Vec thisPt (opposite thisAg)
      "xo" -&gt; Vec thisPt (angleRS thisPt nextPt (+))
      "ox" -&gt; Vec thisPt (angleRS thisPt nextPt (-))
      _    -&gt; None
    [prevOx,nextOx] = [init crv, tail crv]
    [prevPt,thisPt,nextPt] = pts
    [prevAg,thisAg,nextAg] = ags

opposite angle = (angle + 0.5*tau) `mod'` tau
</code></pre>

<p>When the segment has odd convexity, we need to use some trigonometry. This is done in function <code>angleRS</code>.</p>

<pre><code class="haskell">angleRS p0 p1 op = 
  (beta `op` alpha) `mod'` tau
  where
    r = dist p0 p1
    alpha = acos (plateW / r)
    beta = vectorAngle axisX (mkVector p0 p1) 
</code></pre>

<p>In each case we draw the vectors with the function <code>drawVec</code>, which we define as</p>

<pre><code class="haskell">drawVec (Vec pt ag) =
  drawVector yellow pt (vectorFromAngle plateW ag)
drawVec None = return ()

drawVecs xs = mapM_ drawVec xs
</code></pre>

<p><img src="pics/io-vecs.png" alt="io-vecs" /></p>

<p>The data type <code>Vec</code> represents a vector with start point and a direction. We give us a liberty to define non-existing vectors using the constructor <code>None</code>.</p>

<pre><code class="haskell">type Angle = Double
data Vec = Vec Point Angle | None
</code></pre>

<p>The code for this: <a href="code/io-vecs.hs">io-vecs.hs</a></p>

<h2>Painting the segments</h2>

<p>Where the roadline crosses the normal, is desided based on the convexity of point. The <code>ratio</code> of <code>0.00</code> situates at the start point of the normal and the <code>ratio</code> of <code>1.00</code> at the head of the normal with length <code>PlateW</code>.</p>

<pre><code class="haskell">alongAngle ratio angle curved =
  case curved of
    'x' -&gt; vectorFromAngle (ratio*plateW) angle
    'o' -&gt; vectorFromAngle ((1.00-ratio)*plateW) angle
</code></pre>

<p>Each segment is either a <code>Curve</code> or a <code>Straight</code>.</p>

<pre><code class="haskell">type Curv = Char
data Segment = Straight Point Angle Curv Point Angle Curv
             | Curve Point Angle Angle Curv
</code></pre>

<p>We draw the segments accordingly in one of the following functions:</p>

<pre><code class="haskell">drawSeg ratio (Curve p0 a0 a1 curved)
drawSeg ratio (Straight p0 a0 c0 p1 a1 c1)
</code></pre>

<p>A convex arc is drawn by the function <code>drawArcNegative</code> and a concave arc by the function <code>drawArc</code>.</p>

<pre><code class="haskell">drawSeg ratio (Curve p0 a0 a1 curved) =
  case curved of
    'x' -&gt; drawArcNegative green (ratio*plateW) p0 a0 a1
    'o' -&gt; drawArc green ((1.00-ratio)*plateW) p0 a0 a1
</code></pre>

<p>A straight segment is drawn by the function <code>drawVector</code>, and we get its start and end points by function <code>alongAngle</code> defined earlier.</p>

<pre><code class="haskell">drawSeg ratio (Straight p0 a0 c0 p1 a1 c1) = 
  drawVector green point0 (mkVector point0 point1)
  where
    point0 = toPoint p0 (alongAngle ratio a0 c0)
    point1 = toPoint p1 (alongAngle ratio a1 c1)
</code></pre>

<p>We draw a solid line at the ratios of <code>0.30</code> and <code>0.70</code> and the dashed line in middle at <code>0.50</code>. The dashed line may still need refinement.</p>

<pre><code class="haskell">drawSeg1 x = do
  setDash [] 0
  mapM_ (\r -&gt; drawSeg r x) [0.30,0.70]
  setDash [7,2] 0
  drawSeg 0.50 x
drawSegs xs = mapM_ drawSeg1 xs
</code></pre>

<p><img src="pics/io-segs.png" alt="io-segs" /></p>

<p>The code: <a href="code/io-segs.hs">io-segs.hs</a></p>
